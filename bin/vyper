#!/usr/bin/env python3
import argparse
import json
if __name__ == '__main__':

    import os
    import sys
    import vyper
    from vyper.compiler import api

    sys.tracebacklimit = os.environ.get('VYPER_TRACEBACK_LIMIT', 0)

    parser = argparse.ArgumentParser(description='Vyper programming language for Ethereum')
    parser.add_argument('--show-gas-estimates', help='Show gas estimates in ir output mode.', action="store_true")
    parser.add_argument('-f', help='Format to print', default='bytecode', dest='format')
    parser.add_argument('file', nargs='+', help='Vyper sourcecode to compile')
    parser.add_argument('--version', action='version', version='{0}'.format(vyper.__version__))

    args = parser.parse_args()

    def uniq(seq):
        exists = set()
        if isinstance(seq, list):
            return [x for x in seq if not (x in exists or exists.add(x))]
        else:
            return [seq]

    formats = uniq(args.format.split(','))

    output = {}
    output['contracts'] = {}
    output['version'] = vyper.__version__

    print_output = False
    for fname in args.file:
        with open(fname, 'r') as fh:
            code = fh.read()
        try:
            file_output = api(code, show_gas_estimates=args.show_gas_estimates)
        except Exception as e:
            print("File", fname, "failed to compile:")
            print()
            raise e

        file_output['abi_python'] = file_output['abi']
        file_output['abi'] = json.dumps(file_output['abi'])
        file_output['json'] = file_output['abi']  # for backwards compatibility

        # Check that all formats are provided by compiler API
        for i in formats:
            if i not in file_output.keys():
                raise IOError("Invalid format {}".format(i))

        # Filter out unwanted formats
        filtered_output = {}
        for key in file_output.keys():
            if key in formats:
                if key in ['abi', 'bytecode', 'bytecode_runtime']:
                    filtered_output[key] = file_output[key]
                else:
                    print("{}.{}:".format(fname, key), file=sys.stderr)
                    print(file_output[key], file=sys.stderr)

        # Only print output if at least one file was updated
        if filtered_output:
            print_output = True
            # For each file, set
            output['contracts'][fname] = filtered_output

    if print_output:
        print(json.dumps(output))
